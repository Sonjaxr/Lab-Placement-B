# Daily Log: 2025-09-11

## Tasks for Today
- [ ] Look into Phenopacket as well as Phenopacket python
- [ ] Look into JsonB in PostgreSQL
- [ ] Check how and whether JasonB can work/portray phenopackets
- [ ] Check how individuals and reports can be implemented as phenopackets

## New Knowledge
### Phenopacket:
- Phenopackets are a standardized way to share medical & clinical information about patients
    - particularly focusing on their observable characteristics (phenotypes) & genetic data.
**What are Phenopackets?**
 Like A digital medical passport containing:
 - Patient symptoms & physical characteristics
 - Genetic information
 - Disease diagnoses
 - Treatment history
 - Family medical history
**Why are they needed?**
Different hospitals & research centers store medical data differently.
When a rare disease patient sees specialists across multiple institutions, sharing data becomes difficult.
- Phenopackest provide universal langauge for medical data exchange allowing:
     - Share patient data between institutions
     - Conduct research across multiple datasets
     - Help diagnose rare diseases by comparing cases globally
**How are Phenopackets implemented?**
They use several standard formats: 
- Data Format:
    - Stored as JSON or Protocol Buffers (binary format)
    - Similar to JSONB - optimized for both human readability and machine processing
- Standard Vocabularies:
    - HPO (Human Phenotype Ontology): Standardized terms for phenotypes/symptoms (e.g. "HP:0001250" means seizure)
    - MONDO (Monarch Disease Ontology): Standardized terms for diseases/ disease classification
    - LOINC (Logical Observation Identifiers Names and Codes): Standardized codes for lab tests & measurements
- Example Structure of a Phenopacket:
```json
{
    "id": "example-phenopacket-001",
    "subject": {
      "id": "patient-001",
      "timeAtLastEncounter": {
        "age": {
          "iso8601duration": "P25Y"
        }
      },
      "sex": "FEMALE"
    },
    "phenotypicFeatures": [
      {
        "type": {
          "id": "HP:0001250",
          "label": "Seizures"
        }
      },
      {
        "type": {
          "id": "HP:0002376",
          "label": "Developmental regression"
        }
      }
    ],
    "diseases": [
      {
        "term": {
          "id": "OMIM:607208",
          "label": "Dravet syndrome"
        },
        "onset": {
          "age": {
            "iso8601duration": "P6M"
          }
        }
      }
    ],
    "metaData": {
      "created": "2024-01-15T10:30:00Z",
      "createdBy": "clinical-genetics-team",
      "resources": [
        {
          "id": "hp",
          "name": "Human Phenotype Ontology",
          "url": "http://purl.obolibrary.org/obo/hp.owl",
          "version": "2024-01-01",
          "namespacePrefix": "HP",
          "iriPrefix": "http://purl.obolibrary.org/obo/HP_"
        }
      ],
      "phenopacketSchemaVersion": "2.0.0"
    }
  }
  ```
- Adding Publications:
    - Phenopackets can include references to scientific publications
    - Helps link patient data to relevant research articles
    - Done using the externalReferences field in the Phenopacket schema
    Database Schema for Publications:
    ```sql
     -- PUBLICATIONS table (normalized approach)
  CREATE TABLE publications (
      publication_id UUID PRIMARY KEY,
      pmid VARCHAR(20) UNIQUE,
      doi VARCHAR(200) UNIQUE,
      title TEXT,
      journal VARCHAR(500),
      publication_date DATE,
      authors JSONB,  -- Array of author names
      metadata JSONB   -- Additional publication info
  );

  -- PATIENT_PUBLICATIONS junction table (Many-to-Many)
  CREATE TABLE patient_publications (
      patient_id UUID REFERENCES patients(patient_id),
      publication_id UUID REFERENCES publications(publication_id),
      phenopacket_version UUID REFERENCES phenopackets(phenopacket_id),
      mention_type VARCHAR(50), -- 'case_report', 'cohort_member', 'family_study'
      is_anonymized BOOLEAN DEFAULT true,
      consent_given BOOLEAN,
      notes TEXT,
      PRIMARY KEY (patient_id, publication_id)
  );

  -- Index for quick lookups
  CREATE INDEX idx_pub_patient ON patient_publications(patient_id);
  CREATE INDEX idx_pub_pmid ON publications(pmid);
- Valditation Rules:
    1. Required Fields:
        - id - Unique identifier for the phenopacket
        - metaData - Must include version and resources
        - subject OR biosample - At least one must be present
    2. Use Standard Codes:
        - HPO for symptoms: HP:0001250
        - OMIM/MONDO for diseases: OMIM:607208
        - LOINC for lab tests: LOINC:2947-0
        - HGNC for genes: HGNC:11389
    3. Time Formats:
        - Ages: ISO 8601 duration: P25Y (25 years), P6M (6 months)
        - Timestamps: ISO format: 2024-01-15T10:30:00Z
- Quick References: Common Fields
```sql
 # Age representations
  "P25Y"          # 25 years
  "P25Y6M"        # 25 years, 6 months  
  "P6M"           # 6 months
  "P10D"          # 10 days

  # Sex options
  "UNKNOWN_SEX", "FEMALE", "MALE", "OTHER_SEX"

  # Severity levels (HPO codes)
  "HP:0012825"    # Mild
  "HP:0012826"    # Moderate
  "HP:0012827"    # Borderline
  "HP:0012828"    # Severe
  "HP:0012829"    # Profound

  # Common onset terms
  "HP:0003577"    # Congenital onset
  "HP:0003593"    # Infantile onset
  "HP:0003621"    # Juvenile onset
  "HP:0003581"    # Adult onset
  ```
  
#### Phenopacket Python:
- The official Python library for creating, reading, and working with phenopackets programmatically. It's the
  practical implementation that lets you actually build and manipulate phenopackets in code.
- It Provides:
    - Python classes that match the phenopacket schema
    - Methods to create, validate, and serialize phenopackets
    - Conversion between JSON and Python objects
    - Integration with medical ontologies (HPO, MONDO, etc.)
- Installation:
    - pip install phenopacket
- Key Features:
    - Create Phenopackets: Build phenopackets from scratch using Python objects
    - Validation: Ensure phenopackets conform to the schema and use valid ontology terms
    - Serialization: Convert phenopackets to/from JSON for storage or transmission
- Key Benefits:
    1. Type Safety: Python classes ensure correct data structure
    2. Validation: Built-in schema validation
    3. Interoperability: Easy conversion to/from JSON
    4. Protocol Buffers: Efficient binary serialization
    5. Integration Ready: Works with databases, APIs, and file systems

### JasonB:
- Special way databases store JSON data.
- JSON (JavaScript Object Notation): simple text format to store structured data
-    - Filing system to nest folders & documents inside each other
- JSONB (Binary JSON): JSON data converted into special binary format by the database (primarily PostgreSQL)
    - Removed duplicate keys & whitespace
    - Faster to search & filter
    - Can create indexes for faster queries
    - Slightly slower to insert due to conversion 
- When to use JSONB:
    - Store flexible, semi-structured data (like user preferences, product configurations)
    - Search & filter JSON data frequently
    - Build applications where data structure might change over time
    - Combine the flexibility of NoSQL with the power of SQL databases

### JSONB + Phenopacket:
- JSONB is a great fit for storing phenopackets in PostgreSQL
1. Natural Fit:
  - Phenopackets are defined as JSON schemas
  - JSONB stores JSON data efficiently
  - No data transformation needed
2. Flexible Medical Data:
    - Different patients have different symptoms/conditions
    - JSONB handles varying data structures easily
    - New medical fields can be added without changing database schema


## To Do
-  Beibehalten + zusätzliche phenotypen 
- Varianten normalisierung via:
  - VEP Ensemble haben gutes API
  - ANNOVAR
  - SnpSift SnpEff
- Mutalizer & Variant Validator 
- möglischts stabil und leicht nicht viele resourcen 
- via API ohne download 
- internal/external pseudonyme 
- Reports mit zuordnung zu patienten und publication
- many reports for same patient if new phenotypes reported.

- Schema für reports und publications 
- mit Phenopackets das alle infos von google spreadsheets enthält 
- comment field mit gespeicherten voll text (500W report) 
- Ist es sinnvoll nur den report zu haben oder auch eine individuals tabelle um reports zu verlinken
- Intern selbes pseudonym gewählt flagged und option den existierenden patient zu editieren
- plannung in md files subordner mit milestones
- feature branch aus issue verweisung auf md files 
- agent um info zu extrahieren aus lab logs 
- MCPs retrieval tool
